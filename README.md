# Учебная Практика

 
ВВЕДЕНИЕ
Данный отчёт является приложением к выполненному заданию по учебной практике и демонстрацией результатов для оценки по работе. В процессе выполнения учебной практики различных трудностей в связи с недостатком прикладных знаний по дисциплине не возникало. Работа выполнена на основе учебной программы весеннего семестра с использованием источников, представленных в списке литературы.
Необходимо реализовать программу, которая будет считывать текст из файла и с минимальными погрешностями разбивать его на массив отдельных слов. Далее, согласно параметрам выбранного варианта, необходимо отсортировать   этот массив слов. Путь либо название считываемого файла должно вводиться через консоль. Отсортированный массив необходимо вывести в выходной файл. Также необходимо вывести информацию с простейшим анализом введенного текста и в консоль, и в отдельный файл с данными:
•	исходный текст
•	параметры выбранного варианта
•	количество слов в исходном тексте
•	время выполнения сортировки
•	количество слов на каждую букву алфавита
Необходимо провести 10 тестов, то есть повторить такие действия с разными по длине (от 3 тыс. до 15 тыс. символов) и структуре текстами. Соответственно, должно получиться 30 файлов – 10 файлов с входными текстами, 10 с отсортированными массивами и 10 с анализированием текстов. 
1	Индивидуальный вариант
Индивидуальные параметры для каждого варианта представлены на рисунке (рисунок 1)
Рисунок 1 – Параметры вариантов
Выполненный вариант работы – 15. Следовательно было необходимо обработать текст кириллицы, разбив его на слова без учета чисел, отсортировать эти слова по возрастанию сортировкой вставками. 
 
2	Блок-схема алгоритма программы
Блок-схема алгоритма программы представлена на рисунке 2
 
Рисунок 2 – Блок-схема алгоритма
 
3	Описание алгоритма программы
3.1	 Описание основной функции main
3.1.1	Подключение поддержки кириллицы в консоли
3.1.2	Создание переменной name_file типа string, в которую с консоли запишется название файла, введенное пользователем, и переменной original_string типа string, в которой будет находиться исходный текст 
3.1.3	Создается вектор строк words, в него записывается вывод функции splitString
3.1.4	Вызывается функция sortAndTime
3.1.5	Вызывается функция writingToFileResult
3.1.6	Создается вектор типа int, в него записывается вывод функции numberWords
3.1.7	Вызывается функция writingToFileAnalysis
3.2	 Описание функции splitString
Функция принимает переменную имени файла name_file, и исходную строку, возвращает массив слов
3.2.1	Создается переменная file_original типа fstream, для работы с файлом
3.2.2	Открывается файл с именем original + name_file
3.2.3	Если файл открылся, то считываем символ из файла, если получилось, то прибавляем символ к исходной строке
3.2.4	Закрываем файл
3.2.5	Если файл не открылся, выводим в консоль, что исходный файл не открылся и досрочно завершаем программу
3.2.6	Создается пустой вектор строк words, и пустую строку s
3.2.7	К строке добавляем кавычки по обе стороны
3.2.8	Запускается цикл, который идет по всем символам строки, кроме последнего
3.2.9	Каждую итерацию цикла, мы проверяем символ буква русского алфавита или тире, и, что за тире, идет буква и длина слова не равна нулю. Если так, то добавляем к s символ
3.2.10	 Если символ буква большого регистра, а следующий символ все, кроме букв обоих регистров, или символ буква маленького регистра, а следующий символ все кроме букв маленького регистра, и не равен -, то добавляем слово в массив слов и обнуляем строку
3.3	Описание функции writingToFileResult
	Функция принимает строку имени файла и вектор слов 
3.3.1	Создается переменная файла, и открывается файл
3.3.2	Проходимся по всему вектору слов и записываем каждое слово в файл  
3.3.3	Закрываем файл 
3.4	 Описание функции numberWords
	Функция принимает вектор слов, возвращает вектор количества слов на каждую букву 
3.4.1	Создается вектор длиной 33, каждый элемент которого, количество слов, первая буква имеет в алфавите номер равный индексу элемента
3.4.2	Проходимся по всему вектору слов и каждый раз проходимся по всему алфавиту, и если первая буква слова совпала с какой-то буквой из алфавита, то увеличиваем элемент из массива количества слов с номером буквы в алфавите 
3.5	 Описание функции sort
	Функция принимает вектор слов со ссылкой, возвращает время сортировки 
3.5.1	Замеряем время до сортировки 
3.5.2	Проходимся по массиву слов и записываем в временную переменную текущее значение элемента массива. Также запоминаем предыдущий индекс
3.5.3	Потом запускаем новый цикл, пока предыдущий индекс больше или равен нулю, а номер в алфавите текущего элемента меньше номера в алфавите предыдущего элемента
3.5.4	И каждую итерацию этого цикла переставляем элементы и понижаем предыдущий индекс на 1
3.5.5	Замеряем время после сортировки 
3.6	 Описание функции writintToFileAnalysis
Функция принимает строку имени файла, строку с текстом, количество слов, вектор количества слов на каждую букву и время
3.6.1	Создается переменная файла, и открывается файл
3.6.2	Записывается в файл информация
3.6.3	Выводится в консоль информация
3.6.4	Создается строка с нижним регистром 
3.6.5	Проходимся по всему вектору количества слов на каждую букву и выводим соответствующую букву из нижнего регистра и элемент соответствующий элемент этого вектора
3.6.6	Закрываем файл
3.7	 Описание функции number
Принимает строку, возвращает номер первого символа в алфавите  
3.7.1	Если символ из нижнего регистра, во возвращаем номер в нижнем регистре, иначе если символ большая Ё, то возвращаем номер маленькой ё, иначе, возвращаем номер символа, полученного путем прибавления к нему номера маленькой а в таблице ASCII и вычитания из этого номера большой А  
4	Тестирование программы и графики
4.1	Проверка кол-ва слов
Для проверки кол-ва слов счётчиком является Microsoft Word. На рисунках 3-11 представлены тесты работы программы на 2 текстах
 Рисунок 3 - Исходный текст №1



Рисунок 4 - Отсортированный текст №3
 
Рисунок 5 - Анализ текста №3
 
Рисунок 6 - Анализ текста №3
Для текста №3 Microsoft Word насчитал 315 слов, программа насчитала 316.

 
Рисунок 7 - Проверка текста №3
 
 
Рисунок 8 - Исходный текст №5
 
Рисунок 9 - Отсортированный текст №5
 
Рисунок 10 - Анализ текста №5
 
Рисунок 11 - Проверка текста №5
Для текста №3 Microsoft Word насчитал 429 слов, программа насчитала 427.
4.2	 Анализ сложности
График зависимости времени выполнения сортировки от количества слов представлен на графике 1
 
График 1 - Зависимость времени сортировки от кол-ва символов
Можно сделать вывод, что при увеличении кол-ва символов в тексте, время выполнения сортировки возрастает прямо пропорционально. 
Рассмотрим сложность сортировки Вставками. Сложность данного метода варьируется от O(𝑁^2) в худшем случае и до O(N) в лучшем случае не было обменов. 

 
5	Работа с Github
5.1	 Загрузка репозитория
В процессе написания кода, также была осуществлена практика в выгрузке программы на github. Было загружено 6 коммита в репозиторий для учебной практики. Также был создан файл README.md, описывающий принцип работы программы. Файл содержит в себе область применения программы, скриншоты с исходными данными, результатами работы, описания блоков кода на языке C++; Загрузка коммитов показана на рисунке 12  
 
Рисунок 12 – Коммиты на Github
Процесс загрузки в репозиторий достаточно прост: по мере написания кода, после каждого «идейного» изменения необходимо обновлять репозиторий, отправляя коммиты. Сначала необходимо нажать на вкладку «Git» на верхней панели Visual Studio (рисунок 13), после нужно на вкладку «Фиксация или скрытие…» (рисунок 14), и ввести в поле какие изменения были сделаны (рисунок 15).
 
Рисунок 13 – Открытие вкладки «Git»
 
Рисунок 14 – Открытие вкладки «Фиксация или скрытие…»
 
Рисунок 15 – Добавление описания изменений 
 
5.2	 Файл README.md
После завершения работы с проектом, был оформлен файл README.md. Текст файла README.md содержит полное пояснение к программе, подробное описание всех частей кода, их функций в отдельности. Также в файле имеются скриншоты для более наглядного понимания о чём идёт речь в тексте. Во фрагментах описания кода присутствует блок непосредственного встроенного кода на C++. Скриншоты файла README представлены на рисунках 16 - 18
 

ЗАКЛЮЧЕНИЕ
В ходе работы мною была реализована программная функция на языке C++. 
При корректно введенных входных данных программа сортирует слова текста, считываемого из файла, и выводит результат в выходной файл. Кроме того, по завершении работы алгоритма на консоли и в отдельном файле можно увидеть анализ исходного текста: количество слов на каждую букву алфавита. Также рядом с анализом текста можно увидеть исходный текст, количество слов в нем, параметры варианта и время выполнения программной функции.
Таким образом, для успешного выполнения поставленной задачи, был изучен принцип работы алгоритма сортировки методом вставками и его возможная реализация в коде на языке C++. Для выполнения задач помимо сортировки, были реализованы остальные функции исходного кода, имеющие вспомогательный характер (разделить текст на слова и числа, записать результаты в файл).
После реализации программного кода, были проведены 10 тестов на файлах с различным количеством символов. По результатам тестов был построен график зависимости времени от количества входных данных. После построения был сделан вывод. При небольших размерах входных данных время сортировки практически не отличается, а периодический рост и падения во времени можно объяснить особенностью системы и неточностью в измерениях. Однако, при значительном увеличении входных данных можно однозначно сказать, что время сортировки напрямую зависит от входного количества символов.
Для GitHub были изучены базовые принципы работы на платформе: создание публичного репозитория, выгрузка файла проекта в репозиторий, создание README файла проекта. 
Программа выполняет поставленную задачу согласно варианту задания, в зависимости от исходных данных.
 
СПИСОК ИСПОЛЬЗОВАННОЙ ЛИТЕРАТУРЫ
1	Документация Microsoft Docs Справочник по языку C++ - URL: https://docs.microsoft.com/ru-ru/cpp/cpp/cpp-language-reference?view=msvc-170
2	Справочник по языку C++ cplusplus.com – URL: 
https://m.cplusplus.com/
3	Справочник по языку C++ cppreference.com – URL: 
https://en.cppreference.com/w/
4	Курс лекций по дисциплине «Основы программирования» за весенний семестр 2022 г.
5	Справочник по работе с Github – URL: 
https://docs.github.com/en
 
#include <iostream>
#include <string>
#include <iostream>
#include <Windows.h> 
#include <vector> 
#include <fstream>

using namespace std;

vector<string> splitString(string file_name, string& original_string);
int sort(vector <string>& words);
int number(string str);
void writingToFileResult(string name_file, vector<string> words);
vector<int> numberWords(vector<string> words);
void writingToFileAnalysis(string name_file, string original_string, int time, int word_count, vector<int> number_words_array);

int main()
{
    setlocale(0, ""); // поддержка кириллицы в консоли (вывод)

    string name_file, original_string; //переменные имени файла и исходной строки
    cout << "Введите номер файла: ";
    cin >> name_file;

    //разбивка строки, полученной из текста, на массив слов
    vector <string> words = splitString(name_file, original_string);

    //сортировка и время 
    int time = sort(words);

    //запись в файл result
    writingToFileResult(name_file, words);

    //подсчет количества слов на каждую букву
    vector<int> number_words_array = numberWords(words);

    //запись в файл analysis 
    writingToFileAnalysis(name_file, original_string, time, words.size(), number_words_array);

    return 0;
}

vector<string> splitString(string name_file, string& original_string)
{
    fstream file_original; //создаем переменную файла

    file_original.open("original_" + name_file + ".txt", ios::in); // открываем файл на запись из файла

    vector<string> words;
    string s = "";

    char ch;

    if (file_original.is_open()) //если файл открылся 
    {
        while (file_original.get(ch)) //пока можем считать символ из файла
        {
            original_string += ch;; //прибавляем символ к строке 
        }
        file_original.close(); // Закрытие файла
    }
    else
    {
        cout << "Исходный файл не открылся";
        exit(0);
    }

    original_string = '"' + original_string + '"'; //добавляем кавычки, чтобы потом не было проблем со считыаванием последнего символа

    char symbol, symbol_next;

    for (int i = 0; i < original_string.length() - 1; i++)
    {
        symbol = original_string[i];
        symbol_next = original_string[i + 1];

        if ((symbol >= 'А' && symbol <= 'Я' || symbol >= 'а' && symbol <= 'я' || symbol == 'Ё' || symbol == 'ё') //если символ строки буква из кириллицы 
            || //или 
            (symbol == '-' && (symbol_next >= 'А' && symbol_next <= 'Я' || symbol_next >= 'а' && symbol_next <= 'я' || symbol_next == 'Ё' || symbol_next == 'ё') && s.size() != 0)) //символ это -, а дальше идет буква из кириллицы и размер строки не равен 0, то есть есть часть слова перед тире

        {
            s += symbol; //собираем слово 
            if ((((symbol >= 'А' && symbol <= 'Я') || symbol == 'Ё') && //если символ буквы большого регистра
                ((symbol_next < 'А' || symbol_next > 'Я' && symbol_next < 'а' || symbol_next > 'я') && symbol != 'Ё' && symbol != 'ё')) //а следующий символ - все кроме букв обоих регистров
                || //или 
                (((symbol >= 'а' && symbol <= 'я') || symbol == 'ё') && //символ - буква маленького регистра
                    (symbol_next < 'а' || symbol_next > 'я') && symbol_next != 'ё' && symbol_next != '-') //а следующий символ - все кроме букв маленького регистра
                )
            {
                words.push_back(s); //добавляем в массив строку
                s = ""; //обнуляем строку
            }
        }
    }
    return words;
}

int sort(vector <string>& words)
{
    int start_time = clock();

    string temp; // временная переменная для хранения значения элемента сортируемого массива
    int last_index; // индекс предыдущего элемента

    for (int i = 1; i < words.size(); i++)
    {
        temp = words[i]; // инициализируем временную переменную текущим значением элемента массива
        last_index = i - 1; // запоминаем индекс предыдущего элемента массива
        while (last_index >= 0 && number(words[last_index]) > number(temp)) // пока индекс не равен 0 и предыдущий элемент массива больше текущего
        {
            words[last_index + 1] = words[last_index]; // перестановка элементов массива
            words[last_index] = temp;
            last_index--;
        }
    }
    int end_time = clock();
    return end_time - start_time;
}

int number(string str)
{
    string cyrillic_low_reg = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя"; //алфавит русский

    if (str[0] >= 'а' && str[0] <= 'я' || str[0] == 'ё') //если нижнего регистра то возвращем номер в русском алфавите
    {
        return cyrillic_low_reg.find(str[0]);
    }
    else //иначе
    {
        if (str[0] == 'Ё') //если Ё то ищем где маленькая Ё находится
        {
            char ch = 'ё';
            return cyrillic_low_reg.find(ch);
        }
        char ch = str[0] + 'а' - 'А'; //если не Ё то ищем где находится маленькая буква за счет нахождения кода маленькой буквы, за счет прибавления к большой букве разности между маленькой и большой буквой
        return cyrillic_low_reg.find(ch);
    }
}

void writingToFileResult(string name_file, vector <string> words)
{
    fstream file_result;
    file_result.open("result_" + name_file + ".txt", ios::out); // открываем файл на запись в него, если файла нет, то он создастся

    //вывод слов
    for (int i = 0; i < words.size(); i++)
    {
        file_result << words[i] << endl;
    }
    file_result.close();
}

vector<int> numberWords(vector<string> words)
{
    vector<int> number_words_array(33); //массив длиной 33, изначально заполнен нулями. 
    //Каждый элемент - это количество слов на букву, номер в алфавите которой, равен индексу элемента в массиве

    string cyrillic_high_reg = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"; //алфавит русский
    string cyrillic_low_reg = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя"; //алфавит русский
    for (int i = 0; i < words.size(); i++)
    {
        for (int j = 0; j < cyrillic_high_reg.size(); j++) //проходим по всему массиву количества
        {
            if (cyrillic_high_reg[j] == words[i][0]) //если первая буква равна какой-то букве из верхнего регистра, то увеличиваем
                number_words_array[j]++;
            if (cyrillic_low_reg[j] == words[i][0]) //если первая буква равна какой-то букве из нижнего регистра, то увеличиваем
                number_words_array[j]++;
        }
    }
    return number_words_array;
}

void writingToFileAnalysis(string name_file, string original_string, int time, int word_count, vector<int> number_words_array)
{
    fstream file_analysis;

    file_analysis.open("analysis_" + name_file + ".txt", ios::out); // открываем файл на запись в него, если файла нет, то он создастся

    file_analysis
        << "Введенный текст: " << endl
        << original_string << endl
        << "Вариант 15: кириллица, по алфавиту, по возрастанию, игнорировать числа, сортировка вставками " << endl
        << "Количество слов: " << word_count << endl
        << "Время сортировки: " << static_cast<double>(time) / 1000 << " сек" << endl //static_cast это приведение типа
        << "Статистика: " << endl;

    cout
        << "Введенный текст: " << endl
        << original_string << endl
        << "Вариант 15: кириллица, по алфавиту, по возрастанию, игнорировать числа, сортировка вставками " << endl
        << "Количество слов: " << word_count << endl
        << "Время сортировки: " << static_cast<double>(time) / 1000 << " сек" << endl //static_cast это приведение типа
        << "Статистика: " << endl;

    string cyrillic_low_reg = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя"; //алфавит русский

    //вывод количества слов на каждую букву
    for (int i = 0; i < number_words_array.size(); i++)
    {
        file_analysis << cyrillic_low_reg[i] << ": " << number_words_array[i] << endl; //выводим букву и количество слов на эту букву
        cout << cyrillic_low_reg[i] << ": " << number_words_array[i] << endl; //выводим букву и количество слов на эту букву
    }
    file_analysis.close(); //закрываем файл
}


