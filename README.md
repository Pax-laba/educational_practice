# educational_practice
Учебная Практика 


 
ВВЕДЕНИЕ
Данный отчёт является приложением к выполненному заданию по учебной практике и демонстрацией результатов для оценки по работе. В процессе выполнения учебной практики различных трудностей в связи с недостатком прикладных знаний по дисциплине не возникало. Работа выполнена на основе учебной программы весеннего семестра с использованием источников, представленных в списке литературы.
Необходимо реализовать программу, которая будет считывать текст из файла и с минимальными погрешностями разбивать его на массив отдельных слов. Далее, согласно параметрам выбранного варианта, необходимо отсортировать   этот массив слов. Путь либо название считываемого файла должно вводиться через консоль. Отсортированный массив необходимо вывести в выходной файл. Также необходимо вывести информацию с простейшим анализом введенного текста и в консоль, и в отдельный файл с данными:
•	исходный текст
•	параметры выбранного варианта
•	количество слов в исходном тексте
•	время выполнения сортировки
•	количество слов на каждую букву алфавита
Необходимо провести 10 тестов, то есть повторить такие действия с разными по длине (от 3 тыс. до 15 тыс. символов) и структуре текстами. Соответственно, должно получиться 30 файлов – 10 файлов с входными текстами, 10 с отсортированными массивами и 10 с анализированием текстов. 
1	Индивидуальный вариант
Индивидуальные параметры для каждого варианта представлены на рисунке (рисунок 1)
Рисунок 1 – Параметры вариантов
Выполненный вариант работы – 15. Следовательно было необходимо обработать текст кириллицы, разбив его на слова без учета чисел, отсортировать эти слова по возрастанию сортировкой вставками. 
 
2	Блок-схема алгоритма программы
Блок-схема алгоритма программы представлена на рисунке 2
 
Рисунок 2 – Блок-схема алгоритма
 
3	Описание алгоритма программы
3.1	 Описание основной функции main
3.1.1	Подключение поддержки кириллицы в консоли
3.1.2	Создание переменной name_file типа string, в которую с консоли запишется название файла, введенное пользователем, и переменной original_string типа string, в которой будет находиться исходный текст 
3.1.3	Создается вектор строк words, в него записывается вывод функции splitString
3.1.4	Вызывается функция sortAndTime
3.1.5	Вызывается функция writingToFileResult
3.1.6	Создается вектор типа int, в него записывается вывод функции numberWords
3.1.7	Вызывается функция writingToFileAnalysis
3.2	 Описание функции splitString
Функция принимает переменную имени файла name_file, и исходную строку, возвращает массив слов
3.2.1	Создается переменная file_original типа fstream, для работы с файлом
3.2.2	Открывается файл с именем original + name_file
3.2.3	Если файл открылся, то считываем символ из файла, если получилось, то прибавляем символ к исходной строке
3.2.4	Закрываем файл
3.2.5	Если файл не открылся, выводим в консоль, что исходный файл не открылся и досрочно завершаем программу
3.2.6	Создается пустой вектор строк words, и пустую строку s
3.2.7	К строке добавляем кавычки по обе стороны
3.2.8	Запускается цикл, который идет по всем символам строки, кроме последнего
3.2.9	Каждую итерацию цикла, мы проверяем символ буква русского алфавита или тире, и, что за тире, идет буква и длина слова не равна нулю. Если так, то добавляем к s символ
3.2.10	 Если символ буква большого регистра, а следующий символ все, кроме букв обоих регистров, или символ буква маленького регистра, а следующий символ все кроме букв маленького регистра, и не равен -, то добавляем слово в массив слов и обнуляем строку
3.3	Описание функции writingToFileResult
	Функция принимает строку имени файла и вектор слов 
3.3.1	Создается переменная файла, и открывается файл
3.3.2	Проходимся по всему вектору слов и записываем каждое слово в файл  
3.3.3	Закрываем файл 
3.4	 Описание функции numberWords
	Функция принимает вектор слов, возвращает вектор количества слов на каждую букву 
3.4.1	Создается вектор длиной 33, каждый элемент которого, количество слов, первая буква имеет в алфавите номер равный индексу элемента
3.4.2	Проходимся по всему вектору слов и каждый раз проходимся по всему алфавиту, и если первая буква слова совпала с какой-то буквой из алфавита, то увеличиваем элемент из массива количества слов с номером буквы в алфавите 
3.5	 Описание функции sort
	Функция принимает вектор слов со ссылкой, возвращает время сортировки 
3.5.1	Замеряем время до сортировки 
3.5.2	Проходимся по массиву слов и записываем в временную переменную текущее значение элемента массива. Также запоминаем предыдущий индекс
3.5.3	Потом запускаем новый цикл, пока предыдущий индекс больше или равен нулю, а номер в алфавите текущего элемента меньше номера в алфавите предыдущего элемента
3.5.4	И каждую итерацию этого цикла переставляем элементы и понижаем предыдущий индекс на 1
3.5.5	Замеряем время после сортировки 
3.6	 Описание функции writintToFileAnalysis
Функция принимает строку имени файла, строку с текстом, количество слов, вектор количества слов на каждую букву и время
3.6.1	Создается переменная файла, и открывается файл
3.6.2	Записывается в файл информация
3.6.3	Выводится в консоль информация
3.6.4	Создается строка с нижним регистром 
3.6.5	Проходимся по всему вектору количества слов на каждую букву и выводим соответствующую букву из нижнего регистра и элемент соответствующий элемент этого вектора
3.6.6	Закрываем файл
3.7	 Описание функции number
Принимает строку, возвращает номер первого символа в алфавите  
3.7.1	Если символ из нижнего регистра, во возвращаем номер в нижнем регистре, иначе если символ большая Ё, то возвращаем номер маленькой ё, иначе, возвращаем номер символа, полученного путем прибавления к нему номера маленькой а в таблице ASCII и вычитания из этого номера большой А  
4	Тестирование программы и графики
4.1	Проверка кол-ва слов
Для проверки кол-ва слов счётчиком является Microsoft Word. На рисунках 3-11 представлены тесты работы программы на 2 текстах
 Рисунок 3 - Исходный текст №1



Рисунок 4 - Отсортированный текст №3
 
Рисунок 5 - Анализ текста №3
 
Рисунок 6 - Анализ текста №3
Для текста №3 Microsoft Word насчитал 315 слов, программа насчитала 316.

 
Рисунок 7 - Проверка текста №3
 
 
Рисунок 8 - Исходный текст №5
 
Рисунок 9 - Отсортированный текст №5
 
Рисунок 10 - Анализ текста №5
 
Рисунок 11 - Проверка текста №5
Для текста №3 Microsoft Word насчитал 429 слов, программа насчитала 427.
4.2	 Анализ сложности
График зависимости времени выполнения сортировки от количества слов представлен на графике 1
 
График 1 - Зависимость времени сортировки от кол-ва символов
Можно сделать вывод, что при увеличении кол-ва символов в тексте, время выполнения сортировки возрастает прямо пропорционально. 
Рассмотрим сложность сортировки Вставками. Сложность данного метода варьируется от O(𝑁^2) в худшем случае и до O(N) в лучшем случае не было обменов. 

 
5	Работа с Github
5.1	 Загрузка репозитория
В процессе написания кода, также была осуществлена практика в выгрузке программы на github. Было загружено 6 коммита в репозиторий для учебной практики. Также был создан файл README.md, описывающий принцип работы программы. Файл содержит в себе область применения программы, скриншоты с исходными данными, результатами работы, описания блоков кода на языке C++; Загрузка коммитов показана на рисунке 12  
 
Рисунок 12 – Коммиты на Github
Процесс загрузки в репозиторий достаточно прост: по мере написания кода, после каждого «идейного» изменения необходимо обновлять репозиторий, отправляя коммиты. Сначала необходимо нажать на вкладку «Git» на верхней панели Visual Studio (рисунок 13), после нужно на вкладку «Фиксация или скрытие…» (рисунок 14), и ввести в поле какие изменения были сделаны (рисунок 15).
 
Рисунок 13 – Открытие вкладки «Git»
 
Рисунок 14 – Открытие вкладки «Фиксация или скрытие…»
 
Рисунок 15 – Добавление описания изменений 
 
5.2	 Файл README.md
После завершения работы с проектом, был оформлен файл README.md. Текст файла README.md содержит полное пояснение к программе, подробное описание всех частей кода, их функций в отдельности. Также в файле имеются скриншоты для более наглядного понимания о чём идёт речь в тексте. Во фрагментах описания кода присутствует блок непосредственного встроенного кода на C++. Скриншоты файла README представлены на рисунках 16 - 18
 

ЗАКЛЮЧЕНИЕ
В ходе работы мною была реализована программная функция на языке C++. 
При корректно введенных входных данных программа сортирует слова текста, считываемого из файла, и выводит результат в выходной файл. Кроме того, по завершении работы алгоритма на консоли и в отдельном файле можно увидеть анализ исходного текста: количество слов на каждую букву алфавита. Также рядом с анализом текста можно увидеть исходный текст, количество слов в нем, параметры варианта и время выполнения программной функции.
Таким образом, для успешного выполнения поставленной задачи, был изучен принцип работы алгоритма сортировки методом вставками и его возможная реализация в коде на языке C++. Для выполнения задач помимо сортировки, были реализованы остальные функции исходного кода, имеющие вспомогательный характер (разделить текст на слова и числа, записать результаты в файл).
После реализации программного кода, были проведены 10 тестов на файлах с различным количеством символов. По результатам тестов был построен график зависимости времени от количества входных данных. После построения был сделан вывод. При небольших размерах входных данных время сортировки практически не отличается, а периодический рост и падения во времени можно объяснить особенностью системы и неточностью в измерениях. Однако, при значительном увеличении входных данных можно однозначно сказать, что время сортировки напрямую зависит от входного количества символов.
Для GitHub были изучены базовые принципы работы на платформе: создание публичного репозитория, выгрузка файла проекта в репозиторий, создание README файла проекта. 
Программа выполняет поставленную задачу согласно варианту задания, в зависимости от исходных данных.
 
СПИСОК ИСПОЛЬЗОВАННОЙ ЛИТЕРАТУРЫ
1	Документация Microsoft Docs Справочник по языку C++ - URL: https://docs.microsoft.com/ru-ru/cpp/cpp/cpp-language-reference?view=msvc-170
2	Справочник по языку C++ cplusplus.com – URL: 
https://m.cplusplus.com/
3	Справочник по языку C++ cppreference.com – URL: 
https://en.cppreference.com/w/
4	Курс лекций по дисциплине «Основы программирования» за весенний семестр 2022 г.
5	Справочник по работе с Github – URL: 
https://docs.github.com/en
 
ПРИЛОЖЕНИЕ А
Исходный код программы
#include <iostream>
#include <string>
#include <iostream>
#include <Windows.h> 
#include <vector> 
#include <fstream>

using namespace std;

vector<string> separateWords(string text);
string getText(string name_file);
void writeToResult(string name_file, vector<string> array_of_words);
bool isNumber(string s);
int sort(vector <string>& array_of_words);
int findInAlphabet(char a);
vector<int> getArrayCountWords(vector<string> array_of_words);
void writeToAnalysis(string name_file, string text, int word_count, vector<int> number_words_array, int time);

int main()
{
    setlocale(0, ""); // поддержка кириллицы в консоли (вывод)

    string name_file; //название исходного файла

    cout << "Введите номер файла: ";
    cin >> name_file;

    //функция получения текста
    string text = getText(name_file);

    //функция разбивает текст на слова 
    vector <string> array_of_words = separateWords(text);

    //сортировка Шелла
    int time = sort(array_of_words);

    //запись в файл result
    writeToResult(name_file, array_of_words);

    //подсчет количества слов на каждую букву
    vector<int> number_words_array = getArrayCountWords(array_of_words);

    int words_count = array_of_words.size(); //количество слов

    //запись в файл analysis 
    writeToAnalysis(name_file, text, words_count, number_words_array, time);

    return 0;
}

string getText(string name_file)
{
    string text = ""; //исходная строка
    ifstream file_original; //создаем переменную файла

    file_original.open("original_" + name_file + ".txt"); // открываем файл

    if (file_original.is_open()) //если файл открылся 
    {
        char ch;
        while (file_original.get(ch)) //пока можем считать символ из файла
        {
            text += ch;; //прибавляем символ к строке 
        }
        file_original.close(); // Закрытие файла
    }
    else
    {
        cout << "Файл original не открылся";
        exit(0);
    }
    return text;
}

vector<string> separateWords(string text)
{
    vector<string> array_of_words; //массив слов
    string s = "";

    text = '"' + text + '"'; //добавляем кавычки
    text = '"' + text + '"'; //добавляем кавычки

    string high_letters = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"; //алфавит русский
    string low_letters = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя";
    string numbers = "0123456789";

    for (int i = 2; i < text.length() - 2; i++)
    {
        if (high_letters.find(text[i]) != -1 || low_letters.find(text[i]) != -1) //если символ строки буква из кириллицы

        {
            s += text[i]; //собираем слово 
            if (high_letters.find(text[i + 1]) == -1 && low_letters.find(text[i + 1]) == -1 && text[i + 1] != '-')
            {
                array_of_words.push_back(s); //добавляем в массив строку
                s = ""; //обнуляем строку
            }
        }
        else
        {
            if (numbers.find(text[i]) != -1 || text[i] == ',' && numbers.find(text[i + 1]) != -1) //если символ строки цифра или запятая 
            {
                s += text[i]; //собираем слово 
                if (numbers.find(text[i + 1]) == -1 && text[i + 1] != ',' || numbers.find(text[i + 2]) == -1 && text[i + 1] == ',') //следующий символ не цифра и не запятая или след символ запятая а после не цифра
                {
                    array_of_words.push_back(s); //добавляем в массив строку
                    s = ""; //обнуляем строку
                }
            }
            else
            {

                if (text[i] == '-' && (numbers.find(text[i + 1]) != -1 || ((high_letters.find(text[i + 1]) != -1 || low_letters.find(text[i + 1]) != -1) && s != ""))) //если символ строки минус и следующий символ цифра
                {
                    s += text[i]; //собираем слово 
                }
            }
        }
    }
    return array_of_words;
}

void writeToResult(string name_file, vector <string> array_of_words)
{
    ofstream file_result;
    file_result.open("result_" + name_file + ".txt"); // открываем файл на запись в него

    //вывод слов
    for (int i = 0; i < array_of_words.size(); i++)
    {
        file_result << array_of_words[i] << endl;
    }
    file_result.close();
}

int sort(vector <string>& array_of_words)
{
    string numbers = "0123456789-"; //цифры и минус, то с чего может начинаться число

    int i, j, step, number_tmp, start_time, end_time;
    string tmp;

    vector <string> array_of_numbers;
    vector <string> subarray_of_words;

    //получаем массив чисел и массив слов
    for (i = 0; i < array_of_words.size(); i++)
    {
        if (numbers.find(array_of_words[i][0]) != -1)
            array_of_numbers.push_back(array_of_words[i]);
        else
            subarray_of_words.push_back(array_of_words[i]);
    }

    start_time = clock();
    //сортируем массив слов
    for (step = subarray_of_words.size() / 2; step > 0; step /= 2)
    {
        for (i = step; i < subarray_of_words.size(); i++)
        {
            tmp = subarray_of_words[i];
            number_tmp = findInAlphabet(subarray_of_words[i][0]); //номер в алфавите

            for (j = i; j >= step; j -= step)
            {
                if (number_tmp < findInAlphabet(subarray_of_words[j - step][0]))
                    subarray_of_words[j] = subarray_of_words[j - step];
                else
                    break;
            }
            subarray_of_words[j] = tmp;
        }
    }

    //сортируем массив чисел
    double double_number_tmp, double_number;
    for (step = array_of_numbers.size() / 2; step > 0; step /= 2)
    {
        for (i = step; i < array_of_numbers.size(); i++)
        {
            tmp = array_of_numbers[i];
            if (isNumber(array_of_numbers[i])) //если строка - дробное число 
            {
                double_number_tmp = stod(array_of_numbers[i]); //временной переменной присваиваем число

                for (j = i; j >= step; j -= step)
                {
                    if (isNumber(array_of_numbers[j])) //если строка - дробное число
                    {
                        if (double_number_tmp < stod(array_of_numbers[j - step])) //сравниваем число временной переменной и число array_of_numbers[j - step]
                            array_of_numbers[j] = array_of_numbers[j - step];
                        else
                            break;
                    }
                }
                array_of_numbers[j] = tmp;
            }
        }
    }
    end_time = clock();
    array_of_words = {};

    //сливаем массивы обратно в один массив
    for (i = 0; i < subarray_of_words.size(); i++)
    {
        array_of_words.push_back(subarray_of_words[i]);
    }

    for (i = 0; i < array_of_numbers.size(); i++)
    {
        array_of_words.push_back(array_of_numbers[i]);
    }

    return end_time - start_time;
}

bool isNumber(string s)
{
    try
    {
        double a = stod(s);
        return 1;
    }
    catch (invalid_argument e)
    {
        return 0;
    }
}

int findInAlphabet(char a)
{
    //функция возвращает индекс вхождения символа в алфавит 
    string low_letters = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя";
    string high_letters = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ";

    if (high_letters.find(a) != -1)
        return high_letters.find(a);
    else
        return low_letters.find(a);
}

vector<int> getArrayCountWords(vector<string> array_of_words)
{
    vector<int> count_words_array(33);
    //Каждый элемент массив - это количество слов на букву

    string high_letters = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"; //алфавит русский
    string low_letters = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя";

    for (int i = 0; i < array_of_words.size(); i++) //идем по всему массиву строк
    {
        if (!isNumber(array_of_words[i]))
        {
            count_words_array[findInAlphabet(array_of_words[i][0])]++;// увеличиваем элемент с индексом равным номеру маленькой буквы в нижнем регистре
        }
    }
    return count_words_array;
}

void writeToAnalysis(string name_file, string text, int word_count, vector<int> number_words_array, int time)
{
    ofstream file_analysis;

    file_analysis.open("analysis_" + name_file + ".txt"); // открываем файл на запись в него

    file_analysis
        << "Исходный текст: " << endl
        << "<<" << text << ">>" << endl
        << "Параметры выбранного варианта (22): кириллица, по алфавиту, по возрастанию, учитывать числа, сортировка шелла" << endl
        << "Количество слов: " << word_count << endl
        << "Время сортировки: " << static_cast<double>(time) / 1000 << " с" << endl
        << "Статистика (количество слов на каждую букву алфавита): " << endl;

    cout
        << "Исходный текст: " << endl
        << "<<" << text << ">>" << endl
        << "Параметры выбранного варианта (22): кириллица, по алфавиту, по возрастанию, учитывать числа, сортировка шелла" << endl
        << "Количество слов: " << word_count << endl
        << "Время сортировки: " << static_cast<double>(time) / 1000 << " с" << endl
        << "Статистика (количество слов на каждую букву алфавита): " << endl;

    string lo_reg = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя";

    //вывод количества слов на каждую букву
    for (int i = 0; i < number_words_array.size(); i++)
    {
        file_analysis << lo_reg[i] << ": " << number_words_array[i] << endl;
        cout << lo_reg[i] << ": " << number_words_array[i] << endl;
    }
    file_analysis.close();
}

